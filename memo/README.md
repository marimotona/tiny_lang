#### 概要
フィボナッチ数列を計算して表示できる言語</br></br>

1. 数字リテラル</br>
2. 算術演算子(+,-,*,/)</br>
3. P プリント関数</br>
4. 関数の定義、呼び出し</br></br>


#### 動画内容メモ
Pの中にプログラム全体が入っている</br>
その中を1つずつインクリメントしていき、Pの中を解析していく</br></br>

eval関数内で、文字列の各命令を評価する</br></br>

演算子が先に来て、そのあとに式が来る</br>
ex: 0 + 1 -> + 01

##### 数字の読み方
3 -> 3</br>
33 -> 30 + 3</br>
次に読まなくてはいけない数字がある場合は、最初の数字に10をかけて、その次の数字を足し合わせる</br></br>

321 -> 30 + 2 1 -> 32 1 -> 32 * 10 + 1 -> 321</br>
32まで、2桁の数字を読むやり方で行い、その次の桁が現れた際に、今までの数字(32)を10倍する</br>
1桁ずつ読んでいくうちに、10倍ずつしていき、今の桁の数字を足し合わせる</br>

##### ASCII
数字は文字コード上で連続をしている</br>
文字は小さな整数</br>
0を文字から引くことで、offsetを得ることが出来る -> 数字になる</br>
文字を数字にする</br>

#### 演算の順序
C言語では演算の順序は規定されていないため、</br>
順序を付けるときには、複数の変数を用意して規定する</br></br>

ネストした式が書ける</br>
数字を読んでから式に入れるとネストした式が読めない</br>
eval()の中で、eval()を呼び出すことで可能になる</br></br>

無限ループにならない</br>
数字を読んだ場合にはリターンをするから</br>
演算子を読んでいる間のみ呼び出される</br>

##### LL parser
再帰降下</br>
parsingの種類を覚えておくのは良い

##### Functuion
呼び出し元と定義元</br></br>

言語の仕様</br>
関数名は一文字＆大文字</br></br>

大文字のA-Z</br></br>

各関数につき</br>
100文字をバッファをそのまま、グローバルにアロケートする</br>
オーバーフローのチェックはしない</br></br>

[]のbraketがあった場合、それは関数とする</br>
()の場合は、関数の適用である</br></br>

最後にNULL文字でターミネイトする</br></br>

eval()は、グローバルなpを見ている</br></br>


引数を複数取れるようにする</br></br>

小文字の一文字で引数名とする</br></br>

関数に関数を渡すためにはどうする？</br></br>

stackにローカル変数用にアロケートしておく</br>
関数を関数内で呼び出したときに上書きされないために</br></br>

```c
if ('a' <= *p && *p <= 'z')
    return arg[*p++ - 'a'];
```
複数の引数を解析可能にしている</br>
現在の一の文字を取得し、それがアルファベットの何番目かを</br>
計算し、その後現在の位置を1つ進める

##### Fibonacci
関数の途中で、値を出力するという機能がないのでそれを付ける</br>
print outした値をP自体も返す</br>
bと、a + bを自分自身に渡す</br>

##### UNIX
```shell
head -n
```
コマンドのn行目までを出力する

#### Tips
動く小さいものから作っていく